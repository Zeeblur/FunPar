\def\mytitle{Workbook}
\def\myauthor{Zoe Wall}
\def\contact{40182161@napier.ac.uk}
\def\mymodule{Fundamentals of Parallel Systems (SET09109)}

\documentclass[10pt, a4paper]{article}
\usepackage[a4paper,outer=1.5cm,inner=1.5cm,top=1.75cm,bottom=1.5cm]{geometry}
\onecolumn
\usepackage{graphicx}
\graphicspath{{./images/}}
%colour our links, remove weird boxes
\usepackage[colorlinks,linkcolor={black},citecolor={blue!80!black},urlcolor={blue!80!black}]{hyperref}
%Stop indentation on new paragraphs
\usepackage[parfill]{parskip}
%% all this is for Arial
\usepackage[english]{babel}
\usepackage[T1]{fontenc}
\usepackage{helvet}
\renewcommand{\familydefault}{\sfdefault}
%Napier logo top right
\usepackage{watermark}
%Lorem Ipusm dolor please don't leave any in you final repot ;)
\usepackage{lipsum}
\usepackage{xcolor}
\usepackage{listings}
%give us the Capital H that we all know and love
\usepackage{float}
%tone down the linespacing after section titles
\usepackage{titlesec}
%Cool maths printing
\usepackage{amsmath}
%PseudoCode
\usepackage{algorithm2e}

\titlespacing{\subsection}{0pt}{\parskip}{-3pt}
\titlespacing{\subsubsection}{0pt}{\parskip}{-\parskip}
\titlespacing{\paragraph}{0pt}{\parskip}{\parskip}
\newcommand{\figuremacro}[5]{
    \begin{figure}[#1]
        \centering
        \includegraphics[width=#5\textwidth]{#2}
        \caption[#3]{\textbf{#3}#4}
        \label{fig:#2}
    \end{figure}
}

\newcommand{\figuremacroF}[5]{
	\begin{figure}[#1]
		\centering
		\includegraphics[width=#5\textwidth]{#2}
		\caption[#3]{\textbf{#3}#4}
		\label{fig:#2}
	\end{figure}
}

\lstset{
	escapeinside={/*@}{@*/}, language=C++,
	basicstyle=\fontsize{8.5}{12}\selectfont,
	numbers=left,numbersep=2pt,xleftmargin=2pt,frame=tb,
    columns=fullflexible,showstringspaces=false,tabsize=4,
    keepspaces=true,showtabs=false,showspaces=false,
    backgroundcolor=\color{white}, morekeywords={inline,public,
    class,private,protected,struct},captionpos=t,lineskip=-0.4em,
	aboveskip=10pt, extendedchars=true, breaklines=true,
	prebreak = \raisebox{0ex}[0ex][0ex]{\ensuremath{\hookleftarrow}},
	keywordstyle=\color[rgb]{0,0,1},
	commentstyle=\color[rgb]{0.133,0.545,0.133},
	stringstyle=\color[rgb]{0.627,0.126,0.941}
}

%\thiswatermark{\centering \put(336.5,-38.0){\includegraphics[scale=0.8]{logo}} }
\title{\mytitle}
\author{\myauthor\hspace{1em}\\\contact\\Edinburgh Napier University\hspace{0.5em}-\hspace{0.5em}\mymodule}
\date{}
\hypersetup{pdfauthor=\myauthor,pdftitle=\mytitle}
\sloppy
\begin{document}
	\maketitle	
	
	\setcounter{section}{2}
	\section*{Exercise 2}

	\subsection{Multiplier Process}
	
	\subparagraph{Code}
	
	\hfill	
	
	\begin{lstlisting}[caption = "Multiplier.groovy" \label{lst:multi}]
	void run()
	{
		def i = inChannel.read()
		while (i > 0) {
			// write i * factor to outChannel
			outChannel.write(i*factor)
			// read in the next value of i
			i = inChannel.read()
		}
		outChannel.write(i)
	}		\end{lstlisting}
	
	\begin{lstlisting}[caption = "Consumer.groovy"
	\label{lst:consumer}]
	while ( i > 0 )
	{
	    //insert a modified println statement
	    println "The output is : ${i}"
	    i = inChannel.read()
	}	\end{lstlisting}
	
	\begin{lstlisting}[caption = "RunMultiplier.groovy" \label{lst:runMulti}]
	def processList = [ new Producer ( outChannel: connect1.out() ),
	
		//insert here an instance of multiplier with a multiplication factor of 4
		new Multiplier ( inChannel: connect1.in(),
						outChannel: connect2.out(),
						factor: 4),
		new Consumer ( inChannel: connect2.in() )
	]	\end{lstlisting}
	
	\subparagraph{Output} \hfill
	
	\figuremacro{H}{2-1}{Exercise 2-1}{ - Output from Run Multiplier program.}{0.4}

	\subparagraph{Explanation}
	%Using Listing 2-7 as a basic design implement and test a new process called Multiply that is inserted into the network between the Producer and Consumer processes which takes an input value from the Producer process and multiplies it by some constant factor before outputting it to the Consumer process.  The multiplication factor should be one of the properties of the Multiply process.  To make the output more meaningful you may want to change the output text in the Consumer process.  You should reuse the Producer process from the ChapterExamples project in src package c2.
	
	The \textit{Multiplier.groovy} process (see Listing \ref{lst:multi}) is inserted into the process list between the producer and consumer. The \textit{Producer.groovy} process outputs an integer, that has been provided, to the Multiplier process which then outputs each integer multiplied by a constant factor which is set in the constructor of the Multiplier instance (see line 6 in Listing \ref{lst:runMulti}). The \textit{Consumer.groovy} process prints a meaningful output to the console. 
	\subsection{Integer Sets}
	
	\subparagraph{Code}
	\hfill

	\begin{lstlisting}[caption = "ListToStream.groovy"]
	while (inList[0] != -1)
	{
		// hint: output	list elements as single integers
		for ( i in 0 ..< inList.size)outChannel.write(inList[i])
			inList = inChannel.read()
	} 	\end{lstlisting}	
	
	\begin{lstlisting}[caption = "CreateSetsOfEight.groovy" \label{lst:328}]
	while (v != -1)
	{
		for ( i in 0 .. 7 )
		{
			// put v into outList and read next input
			outList[i] = v
			v = inChannel.read()
		}
		println " Eight Object is ${outList}"
	}	\end{lstlisting}
	
	\begin{lstlisting}[caption = "GenerateSetsOfThree.groovy"]
	void run()
	{
		def threeList = [
			[1, 2, 3], 
			[4, 5, 6], 
			[7, 8, 9], 
			[10, 11, 12], 
			[13, 14, 15], 
			[16, 17, 18],
			[19, 20, 21], 
			[22, 23, 24],
			[-1, -1, -1]]		// terminating list
		for ( i in 0 ..< threeList.size)outChannel.write(threeList[i])
		//write the terminating List as per exercise definition
	}	\end{lstlisting}
	
	\subparagraph{Output} \hfill
	
		
	\figuremacro{H}{2-2}{Exercise 2-2}{ - Output from Run Three to Eight program.}{0.6}
	
	\subsection*{Exercise Questions}
    \subitem	\textit{What change is required to output objects containing six integers?}
    
    Within the \textit{CreateSetsOfEight.groovy} process, change the number of iterations of the for loop. See line 3 of listing \ref{lst:328}. The new line should read 
    
    \begin{lstlisting} [caption = "CreateSetsOfEight.groovy - Change required to output objects containing six integers" \label{lst:change328}]
    //for (i in 0 .. 7) {
    for (i in 0 .. 5) {    \end{lstlisting}
    
    which will now create lists containing 6 integers. This can be improved by changing the number to a variable which is set through the constructor of the process.
    
	\subitem 
	 \textit{How could you parameterise this in the system to output objects that contain any number of integers (e.g. 2, 4, 8, 12)?}
	 
	 The process can be improved by creating a parameter for the size of the output list, bearing in mind the iterations start from zero so the required size should be minus one of the input parameter. This can either be a variable that is set within the constructor of the \textit{CreateSetsOfEight.groovy} process or by user input from the console. 
	\subitem 
	\textit{What happens if the number of integers required in the output stream is not a factor of the total number of integers in the input stream (e.g. 5 or 7) ?}
	
	Some integers from the input stream will not be outputted to the console as they do not make up a full set of numbers. So the set cannot be filled and therefore the set will not display as the process cannot finish.
	
	\setcounter{section}{3}
	\section*{Exercise 3}
	
	\setcounter{subsection}{0}
	\subsection{Reversing GIntegrate}
	
	\figuremacro{H}{3-1network}{Exercise 3-1}{ - Network for process reversing the effect of \textit{GIntergrate.groovy}.}{1.0}
	
	\textit{GNumbers.groovy} outputs a stream of integers starting at zero and incrementing by one each time. \textit{GIntegrate.groovy} increments the stream by an increasing number each time so the difference between the output is increasing. To negate this effect the output from the network should be equal to the output from the initial GNumbers process.
	
	\subsection*{Minus Process} \hfill
	
	\figuremacro{H}{diffNetwork}{Exercise 3-1}{ - Network showing processes for \textit{Differentiate.groovy}.}{1.0}
	
	\subparagraph{Explanation} The minus process works by copying the output value from \textit{GIntegrate.groovy}, e.g 0, 1, 3, 6. One copy is sent straight to inChannel0 of the \textit{Minus.groovy} process, and the other is sent to \textit{GPrefix.groovy} which outputs the stream with a leading zero into inChannel1 - see Figure \ref{fig:diffNetwork}. The \textit{Minus.groovy} process reads both inputs in parallel and minuses the second from the first resulting in an output stream of incrementing numbers (Figure \ref{fig:output3-1minus}).
	
	\subparagraph{Code} \hfill
	
	\begin{lstlisting} [caption = "Minus.groovy" \label{lst:minus}]
    ProcessRead read0 = new ProcessRead ( inChannel0)
	ProcessRead read1 = new ProcessRead ( inChannel1)
	def parRead2 = new PAR ( [ read0, read1 ] )
		
	while (true) {
		parRead2.run()
		// output one value subtracted from the other
		// be certain you know which way round you are doing the subtraction!!
		outChannel.write(read0.value - read1.value)
	} \end{lstlisting}
	
	\begin{lstlisting} [caption = "Differentiate.groovy - see Figure \ref{fig:diffNetwork} for network of this list"]
	def differentiateList = [ new GPrefix ( prefixValue: 0, 
											inChannel: b.in(), 
											outChannel: c.out() ),
										new GPCopy ( inChannel: inChannel,  
											outChannel0: a.out(), 
											outChannel1: b.out() ),
										// insert a constructor for Minus    
										new Minus (inChannel0: a.in(),
											inChannel1: c.in(),
											outChannel: outChannel)
										] \end{lstlisting}
	
	\subparagraph{Output} \hfill
	
	\figuremacro{H}{output3-1minus}{Exercise 3-1}{ - Output from the Differentiate System using the Minus Process.}{0.2}
	
	\subsection*{Negator Process}
	
	\figuremacro{H}{negNetwork}{Exercise 3-1}{ - Network showing processes for \textit{DifferentiateNeg.groovy} (replacement for Differentiate process within Figure \ref{fig:3-1network})}{1.0}
	
	\subparagraph{Explanation}
	The negator process works by using the \textit{GPlus.groovy} process which outputs the sum of the two input channels read in parallel. The first input channel is a copy of the original input, whereas the second input channel is a negative version of the input with a leading zero from \textit{GPrefix.groovy}. 
	
	\subparagraph{Code}\hfill
	
	\begin{lstlisting}[caption = "DifferentiateNeg.groovy" ]
	def differentiateList = [ new GPrefix ( prefixValue: 0, 
											inChannel: b.in(), 
											outChannel: c.out() ),
									new GPCopy ( inChannel: inChannel,  
											outChannel0: a.out(), 
											outChannel1: b.out() ),
									//insert a constructor for Negator
									new Negator ( inChannel: c.in(), outChannel: d.out()),		   
									new GPlus  ( inChannel0: a.in(), 
										inChannel1: d.in(), 
										outChannel: outChannel ) 
									]	\end{lstlisting}
	
	\subparagraph{Output} \hfill
	
	\figuremacro{H}{output3-1neg}{Exercise 3-1}{ - Output from the Differentiate System using the Negator process.}{0.2}
	
	\subsection*{Exercise Questions}
	
	\textit{Which is the more pleasing solution and why?}
	In this case, even though the Negator solution requires an extra process, it can be argued that this is more pleasing as there is less room for error introduced by the order of the values within the Minus solution. However, a more appropriate solution to negating the effects of GIntegrate would be not to send the values through it in the first place.

	\subsection{Sequential Copy Process}
	\hfill
	\subsection*{GSCopy Code}
	
	\begin{lstlisting} [caption = "GSCopy.groovy"
	\label{lst:GSCopy} ]
	void run ()
	{
		while (true)
		{
			def i = inChannel.read()
			// output the input value in sequence to each output channel
			outChannel0.write(i)
			outChannel1.write(i)
		}
	} \end{lstlisting}
	
	\subparagraph{Explanation}
	
	Within the GSCopy the input value is copied by outputting the value to both output channels in sequence not in parallel.
	
	\subsection*{GSPairsA}

	\figuremacro{H}{GPairsAPN}{Exercise 3-2}{ - Process Network diagram of GSPairsA, as the copy is sequential the output is written first to channel \textbf{a} then to channel \textbf{b}.}{1.0}

	\subparagraph{Output} \hfill
	
	\figuremacro{H}{pairsAoutput}{Excercise 3-2}{ -  Output from the Squares system, using the \textit{GSPairsA.groovy} process.}{0.4}
	
	\subsection*{GSPairsB}
	
	\figuremacro{H}{GPairsBPN}{Exercise 3-2}{ - Process Network diagram of GSPairsA, as the copy is sequential the output is written first to channel \textbf{b} then to channel \textbf{a}.}{1.0}

	\subparagraph{Output} \hfill
		
	\figuremacro{H}{pairsBoutput}{Excercise 3-2}{ -  Output from the Squares system, using the \textit{GSPairsB.groovy} process.}{0.2}
	
	\subsection*{Questions}
	
	\figuremacro{H}{GSquaresPN}{Exercise 3-2}{ - Process Network diagram of test system, GSPairs is replaced by GSPairsA and GSPairsB to see the effect.}{1.0}
	
	\textit{Determine the effect of the change between GSPairsA and GSPairsB, why does this happen?} %TODO CHECK
	
	In running \textit{GSPairsA.groovy} the output, shown in Figure \ref{fig:pairsAoutput}, is blank after the header, whereas in running \textit{GSPairsB.groovy} the output, shown in Figure \ref{fig:pairsBoutput}, displays a heading and then a stream of square numbers. The reason for this change is due to the fact \textit{GSCopy.groovy} outputs sequentially and even though the channels are the same, the order in which they are written to is different. See Figures \ref{fig:GPairsAPN} \& \ref{fig:GPairsBPN}. In the instance using \textit{GSPairsA.groovy} the system deadlocks.\textit{GPlus.groovy} reads both inputs in parallel so cannot process the values until both channels have an input. \textit{GTail.groovy} removes the first input it is given and then outputs the remaining numbers. However \textit{GTail.groovy} cannot receive another input until channel a (the channel between \textit{GSCopy.groovy} and \textit{GPlus.groovy}) is free. The instance using \textit{GSPairsB} does not deadlock as channel b - the channel between \textit{GSCopy.groovy} and \textit{GTail.groovy} - is written to first, so will be able to receive and send the next copied value on the next iteration of the sequential copy.
	
	\subsection{GParPrint}
	
	%TODO ANSWER
	   Exercise 3 3   (2 marks)
	Why was it considered easier to build GParPrint as a new process rather than using multiple instances of GPrint to output the table of results?
	
	\setcounter{section}{4}
	\section*{Exercise 4}
	
	\setcounter{subsection}{0}
	\subsection{ResetPrefix}

	\begin{lstlisting}[caption = "Line 25 of ResetPrefix.groovy"]
		inChannel.read()	\end{lstlisting}
		
	\subparagraph{Output}
	
	%TODO display output
	
	\subparagraph{Questions} \hfill
	
	\textit{What happens if line {25} of ResetPrefix Listing 4-1 is commented out? Why?}
	
	When the read line is removed the output alternates between the incrementing reset value and the original numbers. This is because
	the original value is not removed from the system if the channel is not read from.
		
	\textit{Explore what happens if you try to send several reset values hence, explain what happens and provide a reason for this.}
	
	%TODO answer
	dlock
	
	\subsection{ResetSucessor process}

	\subparagraph{Code}
	
		Construct a different formulation of ResetNumbers that connects the reset channel to the GSuccessor process instead of GPrefix.  You will have to write a ResetSuccssor process.  
	
	
	\subparagraph{Output}
	
	\subparagraph{Question}
	\hfill
	\textit{Does it overcome the problem identified in Exercise 1? If not, why not?}

	\setcounter{section}{5}
	\section*{Exercise 5}
	
	\setcounter{subsection}{0}
	\subsection{Varying delay for RunQueue}
	
	   The accompanying web site contains a script, called RunQueue, in package ChapterExercises/src/c5 to run the queue network.  The delays associated with QProducer and QConsumer can be modified.  By varying the delay times demonstrate that the system works in the manner expected.  Correct operation can be determined by the QConsumer process outputting the messages “QConsumer has read 1” to “QConsumer has read 50” in sequence.  What do you conclude from these experiments?
	5.1 
	Varying the delay times makes no difference to the process output, it works as expected regardless of changing the times. This happens because it uses preconditions to 
	
	
	\subsection{Preconditions}
	
	\subparagraph{Code} \hfill
	
	\begin{lstlisting}[caption = "Scale.groovy"]
	while (true)
	{
		switch ( scaleAlt.priSelect(preCon) )
		{
			case SUSPEND :
				//  deal with suspend input      
				suspend.read()
				factor.write(scaling)
				suspended = true
				println "Suspended"		
				preCon[SUSPEND] = false
				preCon[INJECT] = true  
				break
			case INJECT:
				//  deal with inject input
				scaling = injector.read()
				println "Injected scaling is $scaling"
				suspended = false
				timeout = timer.read() + DOUBLE_INTERVAL
				timer.setAlarm(timeout)
				preCon[SUSPEND] = true
				preCon[INJECT] = false
				suspended = false
				break
			case TIMER:
				//  deal with Timer input
				timeout = timer.read() + DOUBLE_INTERVAL
				timer.setAlarm ( timeout )
				scaling = scaling * 2
				println "Normal Timer: new scaling is ${scaling}"
				break
			case INPUT:
				//   deal with Input channel 
				def inValue = inChannel.read()
				def result = new ScaledData()
				result.original = inValue
				result.scaled = inValue * scaling
				outChannel.write( result )
				break
		} //end-switch
	} //end-while		\end{lstlisting}
	
	\subparagraph{Questions} \hfill
      Reformulate the scaling device so that it uses pre-conditions rather than nested alternatives.  Which is the more elegant formulation? Why?
   
   The latter is the more elegant solution because it avoids nested loops.
   
   	\setcounter{section}{6}
   \section*{Exercise 6}
   
   \setcounter{subsection}{0}
   \subsection{Test Case for Three-To-Eight} \hfill
   
   \subparagraph{Code} \hfill
   
   \begin{lstlisting}[caption = "RunThreeToEightTest.groovy"]
   class RunThreeToEightTest extends GroovyTestCase
   {
   		void testThreeToEight()
   		{
   			One2OneChannel genToStream = Channel.one2one()
  	 		One2OneChannel streamToEight = Channel.one2one()
   
  			def gen = new GenerateSetsOfThree ( outChannel: genToStream.out())
   			def list = new ListToStream ( inChannel: genToStream.in(), outChannel: streamToEight.out())
   			def eight = new CreateSetsOfEight ( inChannel: streamToEight.in())
   
   			def testRunList = [gen, list, eight]
   			new PAR(testRunList).run()
   
   			// test output is correct from eight
   			def expectedList = list.inTest
   			def actualList = eight.outTest
   
   			println "exp ${expectedList} + act ${actualList}"
   
   			assertTrue(expectedList == actualList)
   		}
   }   \end{lstlisting}
   
   \subparagraph{Output}
   %TODO add screencap
   
   	\setcounter{section}{7}
	\section*{Exercise 7}
	
	
	\setcounter{subsection}{0}
	\subsection{dead case}
	   Exercise 7 1   (5 marks)
	By placing print statements in the coding for the Server and Client processes see if you can determine the precise nature of the deadlock in the Client Server system.  You will probably find it useful to add a property to the Server process by which you can identify each Server.  


	\setcounter{section}{8}
   \section*{Exercise 8}
   
   \setcounter{subsection}{0}
   \subsection{test case}

   Exercise 8 1   ( 4 marks)
   Modify the Client process c07.Client so that it can ensure that the values returned from the Server arrive in the order expected according to their selectList property.  It should print a suitable message that the test has been undertaken and whether it passed or failed.  You are not to use the GroovyTestCase mechanism because this would require that the CSMux and Server processes would have to terminate, which would require a lot of unnecessary programming.  
   
   	\setcounter{section}{9}
   \section*{Exercise 9}
   
   \setcounter{subsection}{0}
   \subsection{missed test}
   
   Exercise 9 1   ( 5 marks)
   Using the suggestion (Section 9.4.4) made earlier in the chapter, construct an additional process for the event handling system that ensures that the number of missed events is correct.  The additional process should be added to the network of processes.  You may need to modify the EventData class (Section 9.2.4) to facilitate this.
   
   \subsection{MultiStream}
   Exercise 9 2   (5.marks)
   The accompanying exercise package contains a version of the event handling system, RunMultiStream, which allows the creation of 1 to 9 event streams.  By modifying the times associated with each event generation stream and also of the processing system explore the performance of the system.  What do you conclude?
   
   \subsection{multiplexer}
   Exercise 9 3   (6 marks)
   The process EventProcessing has three versions of multiplexer defined within it, two of which are commented out.  By choosing each of the options in turn, comment upon the effect that each multiplexer variation has on overall system performance.
   
   	\setcounter{section}{11}
   \section*{Exercise 11}
   
   \setcounter{subsection}{0}

   \subsection{control}
   Exercise 11 1   (8 marks)
   The Control process in the Scaling system currently updates the scaling factor according to an automatic system.  Replace this with a user interface that issues the suspend communication, obtains the current scaling factor and then asks the user for the new scaling factor that is then injected into the Scaler.  The original and scaled values should also be output to the user interface.
   Total Marks  (60)
   
	
\end{document}
