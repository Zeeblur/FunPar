\def\mytitle{Workbook}
\def\myauthor{Zoe Wall}
\def\contact{40182161@napier.ac.uk}
\def\mymodule{Fundamentals of Parallel Systems (SET09109)}

\documentclass[10pt, a4paper]{article}
\usepackage[a4paper,outer=1.5cm,inner=1.5cm,top=1.75cm,bottom=1.5cm]{geometry}
\onecolumn
\usepackage{graphicx}
\graphicspath{{./images/}}
%colour our links, remove weird boxes
\usepackage[colorlinks,linkcolor={black},citecolor={blue!80!black},urlcolor={blue!80!black}]{hyperref}
%Stop indentation on new paragraphs
\usepackage[parfill]{parskip}
%% all this is for Arial
\usepackage[english]{babel}
\usepackage[T1]{fontenc}
\usepackage{uarial}
\renewcommand{\familydefault}{\sfdefault}
%Napier logo top right
\usepackage{watermark}
%Lorem Ipusm dolor please don't leave any in you final repot ;)
\usepackage{lipsum}
\usepackage{xcolor}
\usepackage{listings}
%give us the Capital H that we all know and love
\usepackage{float}
%tone down the linespacing after section titles
\usepackage{titlesec}
%Cool maths printing
\usepackage{amsmath}
%PseudoCode
\usepackage{algorithm2e}

\titlespacing{\subsection}{0pt}{\parskip}{-3pt}
\titlespacing{\subsubsection}{0pt}{\parskip}{-\parskip}
\titlespacing{\paragraph}{0pt}{\parskip}{\parskip}
\newcommand{\figuremacro}[5]{
    \begin{figure}[#1]
        \centering
        \includegraphics[width=#5\textwidth]{#2}
        \caption[#3]{\textbf{#3}#4}
        \label{fig:#2}
    \end{figure}
}

\newcommand{\figuremacroF}[5]{
	\begin{figure}[#1]
		\centering
		\includegraphics[width=#5\textwidth]{#2}
		\caption[#3]{\textbf{#3}#4}
		\label{fig:#2}
	\end{figure}
}

\lstset{
	escapeinside={/*@}{@*/}, language=C++,
	basicstyle=\fontsize{8.5}{12}\selectfont,
	numbers=left,numbersep=2pt,xleftmargin=2pt,frame=tb,
    columns=fullflexible,showstringspaces=false,tabsize=4,
    keepspaces=true,showtabs=false,showspaces=false,
    backgroundcolor=\color{white}, morekeywords={inline,public,
    class,private,protected,struct},captionpos=t,lineskip=-0.4em,
	aboveskip=10pt, extendedchars=true, breaklines=true,
	prebreak = \raisebox{0ex}[0ex][0ex]{\ensuremath{\hookleftarrow}},
	keywordstyle=\color[rgb]{0,0,1},
	commentstyle=\color[rgb]{0.133,0.545,0.133},
	stringstyle=\color[rgb]{0.627,0.126,0.941}
}

%\thiswatermark{\centering \put(336.5,-38.0){\includegraphics[scale=0.8]{logo}} }
\title{\mytitle}
\author{\myauthor\hspace{1em}\\\contact\\Edinburgh Napier University\hspace{0.5em}-\hspace{0.5em}\mymodule}
\date{}
\hypersetup{pdfauthor=\myauthor,pdftitle=\mytitle}
\sloppy
\begin{document}
	\maketitle	
	
	\setcounter{section}{2}
	\section*{Exercise 2}

	\subsection{Multiplier Process}
	
	\subparagraph{Code}
	
	\hfill	
	
	\begin{lstlisting}[caption = "Multiplier.groovy" \label{lst:multi}]
	void run()
	{
		def i = inChannel.read()
		while (i > 0) {
			// write i * factor to outChannel
			outChannel.write(i*factor)
			// read in the next value of i
			i = inChannel.read()
		}
		outChannel.write(i)
	}		\end{lstlisting}
	
	\begin{lstlisting}[caption = "Consumer.groovy"
	\label{lst:consumer}]
	while ( i > 0 )
	{
	    //insert a modified println statement
	    println "The output is : ${i}"
	    i = inChannel.read()
	}	\end{lstlisting}
	
	\begin{lstlisting}[caption = "RunMultiplier.groovy" \label{lst:runMulti}]
	def processList = [ new Producer ( outChannel: connect1.out() ),
	
		//insert here an instance of multiplier with a multiplication factor of 4
		new Multiplier ( inChannel: connect1.in(),
						outChannel: connect2.out(),
						factor: 4),
		new Consumer ( inChannel: connect2.in() )
	]	\end{lstlisting}
	
	\subparagraph{Output} \hfill
	
	\figuremacro{H}{2-1}{Exercise 2-1}{ - Output from Run Multiplier program.}{0.4}

	\subparagraph{Explanation}
	%Using Listing 2-7 as a basic design implement and test a new process called Multiply that is inserted into the network between the Producer and Consumer processes which takes an input value from the Producer process and multiplies it by some constant factor before outputting it to the Consumer process.  The multiplication factor should be one of the properties of the Multiply process.  To make the output more meaningful you may want to change the output text in the Consumer process.  You should reuse the Producer process from the ChapterExamples project in src package c2.
	
	The \textit{Multiplier.groovy} process (see Listing \ref{lst:multi}) is inserted into the process list between the producer and consumer. The \textit{Producer.groovy} process outputs an integer, that has been provided, to the Multiplier process which then outputs each integer multiplied by a constant factor which is set in the constructor of the Multiplier instance (see line 6 in Listing \ref{lst:runMulti}). The \textit{Consumer.groovy} process prints a meaningful output to the console. 
	\subsection{Integer Sets}
	
	\subparagraph{Code}
	\hfill

	\begin{lstlisting}[caption = "ListToStream.groovy"]
	while (inList[0] != -1)
	{
		// hint: output	list elements as single integers
		for ( i in 0 ..< inList.size)outChannel.write(inList[i])
			inList = inChannel.read()
	} 	\end{lstlisting}	
	
	\begin{lstlisting}[caption = "CreateSetsOfEight.groovy" \label{lst:328}]
	while (v != -1)
	{
		for ( i in 0 .. 7 )
		{
			// put v into outList and read next input
			outList[i] = v
			v = inChannel.read()
		}
		println " Eight Object is ${outList}"
	}	\end{lstlisting}
	
	\begin{lstlisting}[caption = "GenerateSetsOfThree.groovy"]
	void run()
	{
		def threeList = [
			[1, 2, 3], 
			[4, 5, 6], 
			[7, 8, 9], 
			[10, 11, 12], 
			[13, 14, 15], 
			[16, 17, 18],
			[19, 20, 21], 
			[22, 23, 24],
			[-1, -1, -1]]		// terminating list
		for ( i in 0 ..< threeList.size)outChannel.write(threeList[i])
		//write the terminating List as per exercise definition
	}	\end{lstlisting}
	
	\subparagraph{Output} \hfill
	
		
	\figuremacro{H}{2-2}{Exercise 2-2}{ - Output from Run Three to Eight program.}{0.6}
	
	\subsection*{Exercise Questions}
    \subitem	\textit{What change is required to output objects containing six integers?}
    
    Within the \textit{CreateSetsOfEight.groovy} process, change the number of iterations of the for loop. See line 3 of listing \ref{lst:328}. The new line should read 
    
    \begin{lstlisting} [caption = "CreateSetsOfEight.groovy - Change required to output objects containing six integers" \label{lst:change328}]
    //for (i in 0 .. 7) {
    for (i in 0 .. 5) {    \end{lstlisting}
    
    which will now create lists containing 6 integers. This can be improved by changing the number to a variable which is set through the constructor of the process.
    
	\subitem 
	 \textit{How could you parameterise this in the system to output objects that contain any number of integers (e.g. 2, 4, 8, 12)?}
	 
	 The process can be improved by creating a parameter for the size of the output list, bearing in mind the iterations start from zero so the required size should be minus one of the input parameter. This can either be a variable that is set within the constructor of the \textit{CreateSetsOfEight.groovy} process or by user input from the console. 
	\subitem 
	\textit{What happens if the number of integers required in the output stream is not a factor of the total number of integers in the input stream (e.g. 5 or 7) ?}
	
	Some integers from the input stream will not be outputted to the console as they do not make up a full set of numbers. So the set cannot be filled and therefore the set will not display as the process cannot finish.
	
	\setcounter{section}{3}
	\section*{Exercise 3}
	
	\setcounter{subsection}{0}
	\subsection{Reversing GIntegrate}
	
	\figuremacro{H}{3-1network}{Exercise 3-1}{ - Network for process reversing the effect of \textit{GIntergrate.groovy}.}{1.0}
	
	\textit{GNumbers.groovy} outputs a stream of integers starting at zero and incrementing by one each time. \textit{GIntegrate.groovy} increments the stream by an increasing number each time so the difference between the output is increasing. To negate this effect the output from the network should be equal to the output from the initial GNumbers process.
	
	\subsection*{Minus Process} \hfill
	
	\figuremacro{H}{diffNetwork}{Exercise 3-1}{ - Network showing processes for \textit{Differentiate.groovy}.}{1.0}
	
	\subparagraph{Explanation} The minus process works by copying the output value from \textit{GIntegrate.groovy}, e.g 0, 1, 3, 6. One copy is sent straight to inChannel0 of the \textit{Minus.groovy} process, and the other is sent to \textit{GPrefix.groovy} which outputs the stream with a leading zero into inChannel1 - see Figure \ref{fig:diffNetwork}. The \textit{Minus.groovy} process reads both inputs in parallel and minuses the second from the first resulting in an output stream of incrementing numbers (Figure \ref{fig:output3-1minus}).
	
	\subparagraph{Code} \hfill
	
	\begin{lstlisting} [caption = "Minus.groovy" \label{lst:minus}]
    ProcessRead read0 = new ProcessRead ( inChannel0)
	ProcessRead read1 = new ProcessRead ( inChannel1)
	def parRead2 = new PAR ( [ read0, read1 ] )
		
	while (true) {
		parRead2.run()
		// output one value subtracted from the other
		// be certain you know which way round you are doing the subtraction!!
		outChannel.write(read0.value - read1.value)
	} \end{lstlisting}
	
	\begin{lstlisting} [caption = "Differentiate.groovy - see Figure \ref{fig:diffNetwork} for network of this list"]
	def differentiateList = [ new GPrefix ( prefixValue: 0, 
											inChannel: b.in(), 
											outChannel: c.out() ),
										new GPCopy ( inChannel: inChannel,  
											outChannel0: a.out(), 
											outChannel1: b.out() ),
										// insert a constructor for Minus    
										new Minus (inChannel0: a.in(),
											inChannel1: c.in(),
											outChannel: outChannel)
										] \end{lstlisting}
	
	\subparagraph{Output} \hfill
	
	\figuremacro{H}{output3-1minus}{Exercise 3-1}{ - Output from the Differentiate Process.}{0.2}
	
	\subsection*{Negator Process}
	
	\figuremacro{H}{negNetwork}{Exercise 3-1}{ - Network showing processes for \textit{DifferentiateNeg.groovy} (replacement for Differentiate process within Figure \ref{fig:3-1network})}{1.0}
	
	\subparagraph{Explanation}
	
	\subparagraph{Code}
	
	\begin{lstlisting}[caption = "DifferentiateNeg.groovy" ]
	def differentiateList = [ new GPrefix ( prefixValue: 0, 
											inChannel: b.in(), 
											outChannel: c.out() ),
									new GPCopy ( inChannel: inChannel,  
											outChannel0: a.out(), 
											outChannel1: b.out() ),
									//insert a constructor for Negator
									new Negator ( inChannel: c.in(), outChannel: d.out()),		   
									new GPlus  ( inChannel0: a.in(), 
										inChannel1: d.in(), 
										outChannel: outChannel ) 
									]	\end{lstlisting}
	
	\subparagraph{Output}
	
	
	\subsection*{Exercise Questions}
	
	\textit{Which is the more pleasing solution and why?}
	In this case, even though the Negator solution requires an extra process, it can be argued that this is more pleasing as there is less room for error introduced by the order of the values within the Minus solution. However, a more appropriate solution to negating the effects of GIntegrate would be not to send the values through it in the first place.

	\subsection{Exercise 3-2}
	
	\subsection{Exercise 3-3}
	
	
	\title{\textbf{Exercise 4-1}}
	
	When the read line is removed the output alternates between the incrementing reset value and the original numbers. This is because
	the original value is not removed from the system if the channel is not read from.
	
	
	
	5.1 
	Varying the delay times makes no difference to the process output, it works as expected regardless of changing the times. This happens because it uses preconditions to 
	
	the latter situatuon is more 
   
   
   The latter is the more elegant solution because it avoids nested loops.
   
   \bibliographystyle{ieeetr}
   \bibliography{references}

\clearpage
\section{Appendix}

		
\end{document}
